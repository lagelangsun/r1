# 更新3_3：

# 1.更新内容

### 1.1 demo3_3 + main.py：为目前可运行版本，可以运行一个小车的初步控制

① 更新了machine_sort_by_receive的append方法，已经过测试，可以正常运行

###  1.2 B_IOdemo4_thread_test.py：将 B_IOdemo4_thread_test.py维护进项目中

① 在demo3_3基础上尝试使用两种方案启用四个线程分别控制四个小车，只写了伪代码，未经测试。
    方案1 : 初始化的时候开启线程，在线程类的.run()中执行while一直循环，使用if判断全局变量，或者.event().wait()等待触发(更新完信息后更新全局变量或者.event().set())，然后执行控制函数
    方案2 : 每次更新完信息后重新初始化线程，实例化线程类，线程执行完后销毁。

# 2.问题

### 2.1 测试运行版本的时候，stderr.write输出到终端占用时间较多，不注释掉会经常跳帧。注释掉之后在图4(50个工作台)中遍历4个小车进行控制都不会跳帧，感觉可以先写决策，如果在图4中都不会跳帧的话可以不开多线程。

### 2.2 开多线程的话，需要将所有线程里的stdout.write(控制小车的指令)放在控制函数的最后，输出的时候要上锁，否则四个线程可能出现抢占输出的情况。4个子线程需要与主线程通信获取更新完后的数据，需要注释出控制需要哪些数据。如果决策方面还需考虑到四个小车的状态，需要4个子线程之间的通信。

### 
