# 更新4_2:
# 1.更新内容

### 1.1 main.py + A_IO_demo4.py + A_decision_demo1 + A_robot_demo1.py + A_machine.py:目前可运行版本，可对没有9的图进行控制

① 更新了小车类A_robor_demo1, 添加了target(type:list)属性
② 更新了A_descision_demo1, 为决策模块，负责进行决策(目前是同时进行控制)

### 1.2 A_control_demo1.py, A_decision_demo1_clear: 将A_control_demo1.py,维护进项目中,  A_decision_demo1_clear为删掉调试代码的版本

① 如果有时间的话，为后续决策和控制分离做准备，如果控制决策分离的话需要将控制函数从robot类中分离到控制模块中

# 2.问题

## 2.1 没有针对工作台9的决策
## 2.2 小车的运动控制问题较大，碰撞损失金额较多，考虑如何尽量避免小车碰撞

# 更新3_3：

# 1.更新内容

### 1.1 demo3_3 + main.py：为目前可运行版本，可以运行一个小车的初步控制

① 更新了machine_sort_by_receive的append方法，已经过测试，可以正常运行

###  1.2 B_IOdemo4_thread_test.py：将 B_IOdemo4_thread_test.py维护进项目中

① 在demo3_3基础上尝试使用两种方案启用四个线程分别控制四个小车，只写了伪代码，未经测试。
    方案1 : 初始化的时候开启线程，在线程类的.run()中执行while一直循环，使用if判断全局变量，或者.event().wait()等待触发(更新完信息后更新全局变量或者.event().set())，然后执行控制函数
    方案2 : 每次更新完信息后重新初始化线程，实例化线程类，线程执行完后销毁。

# 2.问题

### 2.1 测试运行版本的时候，stderr.write输出到终端占用时间较多，不注释掉会经常跳帧。注释掉之后在图4(50个工作台)中遍历4个小车进行控制都不会跳帧，感觉可以先写决策，如果在图4中都不会跳帧的话可以不开多线程。

### 2.2 开多线程的话，需要将所有线程里的stdout.write(控制小车的指令)放在控制函数的最后，输出的时候要上锁，否则四个线程可能出现抢占输出的情况。4个子线程需要与主线程通信获取更新完后的数据，需要注释出控制需要哪些数据。如果决策方面还需考虑到四个小车的状态，需要4个子线程之间的通信。

### 
